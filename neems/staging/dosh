#!/usr/bin/env bash
# Do - The Simplest Build Tool on Earth.
# Documentation and examples see https://github.com/8gears/do
#
set -e
SCRIPTNAME=`basename "$0"`
SCRIPTDIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
[ "$(basename "$SCRIPTDIR")" = "bin" ] && BASEDIR="${SCRIPTDIR%/*}" || BASEDIR="$SCRIPTDIR"
export STAGE=$(basename $BASEDIR)
export REMOTEDIR="/opt/$(basename $(dirname $BASEDIR))/${STAGE}"
export APPNAME="$(basename $(dirname $BASEDIR))-${STAGE}"
export USERNAME=${APPNAME}
export HOMEDIR=/var/lib/${USERNAME}
export STAGEDIR="${HOMEDIR}/${STAGE}"
cd ${BASEDIR}

# Load some funcs and vars relative to the top-level
GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || true
if [ -z "$GIT_ROOT" ]; then
	source ${BASEDIR}/lib/util.sh
else
	source ${GIT_ROOT}/lib/util.sh
fi
# Save the original push function before we shadow it
eval "$(declare -f push | sed '1s/push/_util_push/')"
ANSIBLE_DIR=${GIT_ROOT}/ansible
INVENTORY_FNAME=${ANSIBLE_DIR}/inventory.yml

clean() {
	rm -rf setup-demo-data demo-data.sql dist neems-api
}

install() {
    # Run this on the remote app server

    # Prevent accidental install of app stuff to wrong server
    which caddy &>/dev/null && { echo "Caddy found. Are you sure this is the app server and not the web router?" >&2; exit 1; }

    _need_root

    _create-system-user ${USERNAME}

    # Move files over to home dir
    mkdir -p ${STAGEDIR}/${STAGE}
    [ -f .env ] && mv .env ${STAGEDIR}
    [ -f Rocket.toml ] && mv Rocket.toml ${STAGEDIR}
    [ -d static ] && rsync --delete -r static ${STAGEDIR}
    chown -R ${USERNAME}:${USERNAME} ${STAGEDIR}

    # Load demo data, if provided
    [ -f demo-data.sql ] && sqlite3 ${STAGEDIR}/neems-api.sqlite < demo-data.sql
    [ -f setup-demo-data ] && ./setup-demo-data ${STAGEDIR}/neems-api.sqlite

    # Setup SystemD if there is a service file
    if [ -f ${BASEDIR}/service ]; then
	cat ${BASEDIR}/service | envsubst > /etc/systemd/system/${APPNAME}.service
	systemctl daemon-reload
	systemctl status ${APPNAME} | grep -q "Loaded.*enabled" || systemctl enable --now ${APPNAME}
    fi
    echo "Wrote /etc/systemd/system/${APPNAME}.service"

    # Not needed for this server
    rm -f caddyfile
    rm -rf dist
}

install-caddy() {
    # This one shoule be run on newtown.energy, not bromine-newtown

    set -e

    _need_root

    # Prevent accidental install of caddy stuff to wrong server
    which caddy &>/dev/null || { echo "Caddy not found. Install it if this is indeed our web router" >&2; exit 1; }

    _apt-get-update
    _apt-get-install gettext-base

    # Pull in our .env values if they exist
    [ ! -f .env ] && cp env.example .env
    _load-env
    [ -z "$CADDY_FQDN" ] && { echo "Error: CADDY_FQDN isn't specified in .env" >&2; exit 1; }
    [ -z "$CADDY_DEST_IP" ] && { echo "Error: CADDY_DEST_IP isn't specified in .env" >&2; exit 1; }
    [ -z "$CADDY_DEST_PORT" ] && { echo "Error: CADDY_DEST_PORT isn't specified in .env" >&2; exit 1; }

    pushd /etc/caddy > /dev/null
    mkdir -p available enabled
    cat ${BASEDIR}/caddyfile | envsubst > available/${APPNAME}.caddyfile

    cd enabled
    ln -sf ../available/${APPNAME}.caddyfile ${APPNAME}.caddyfile

    systemctl reload caddy

    popd > /dev/null

    # Not needed for this server
    rm -f service
}

justpush() {
    _util_push "$@"
}

push() {
    # Run this locally to push to remote

    # Build binary and static pages in parallel
    local api_pid react_pid
    local api_status=0 react_status=0

    # Build our binary in background
    (
        pushd ${NEWTOWN_DIR}/src/neems/core > /dev/null
        bin/dosh release
        popd > /dev/null
    ) &
    api_pid=$!

    # Build our static pages in background
    (
        pushd ${NEWTOWN_DIR}/src/neems/react > /dev/null
        bin/dosh build
        popd > /dev/null
    ) &
    react_pid=$!

    # Wait for both builds and capture their exit statuses
    # If one fails, kill the other
    while kill -0 $api_pid 2>/dev/null || kill -0 $react_pid 2>/dev/null; do
        # Check if API build is done
        if ! kill -0 $api_pid 2>/dev/null; then
            wait $api_pid
            api_status=$?
            if [ $api_status -ne 0 ]; then
                echo "API build failed, killing React build" >&2
                kill $react_pid 2>/dev/null
                wait $react_pid 2>/dev/null
                exit 1
            fi
        fi

        # Check if React build is done
        if ! kill -0 $react_pid 2>/dev/null; then
            wait $react_pid
            react_status=$?
            if [ $react_status -ne 0 ]; then
                echo "React build failed, killing API build" >&2
                kill $api_pid 2>/dev/null
                wait $api_pid 2>/dev/null
                exit 1
            fi
        fi

        # Small sleep to avoid busy waiting
        sleep 0.1
    done

    # Copy built artifacts
    rsync ${NEWTOWN_DIR}/src/neems/core/target/release/neems-api .
    rsync ${NEWTOWN_DIR}/src/neems/core/target/release/neems-admin .
    rsync ${NEWTOWN_DIR}/src/neems/core/target/release/neems-data .

    # Demo data is for demo and staging, but not prod
    #
    if [ "$STAGE" != prod ]; then
	rsync ${NEWTOWN_DIR}/src/neems/core/bin/setup-demo-data .
    else
	rm -f setup-demo-data demo-data.sql
    fi

    rsync -r ${NEWTOWN_DIR}/src/neems/react/dist .

    # Install on remotes
    _util_push "$@"
}

uninstall() {
    # Run this on the remote

    _need_root

    # Remove the service
    systemctl stop ${APPNAME}
    systemctl disable ${APPNAME}
    rm -f /etc/systemd/system/${APPNAME}.service
    systemctl daemon-reload

    userdel ${USERNAME}
    [ -d ${HOMEDIR} ] && rm -rf ${HOMEDIR}
    echo "User ${USERNAME} deleted"

    rm -f /etc/caddy/available/${APPNAME}.caddyfile
    rm -f /etc/caddy/enabled/${APPNAME}.caddyfile
}


"$@" # <- execute the task
[ "$#" -gt 0 ] || printf "Usage:\n\t./${SCRIPTNAME} %s\n" "($(compgen -A function | grep '^[^_]' | paste -sd '|' -))"
