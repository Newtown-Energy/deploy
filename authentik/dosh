#!/usr/bin/env bash
# Do - The Simplest Build Tool on Earth.
# Documentation and examples see https://github.com/8gears/do
#
SCRIPTNAME=`basename "$0"`
BASEDIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )


_add_if_missing_or_empty() {
    # Usage: add_if_missing_or_empty "file" "VARNAME" "new_value"
    local file="$1"
    local varname="$2"
    local new_value="$3"
    
    # Escape regex special characters in varname
    local escaped_varname=$(printf '%s\n' "$varname" | sed -e 's/[][\/.^$*]/\\&/g')
    
    # Create regex patterns
    local empty_regex="^[[:space:]]*${escaped_varname}[[:space:]]*=[[:space:]]*(\"\"|''|)[[:space:]]*$"
    local any_value_regex="^[[:space:]]*${escaped_varname}[[:space:]]*="

    # Check if variable exists with any value
    if grep -qE "$any_value_regex" "$file"; then
        # Check if empty/unset
        if grep -qE "$empty_regex" "$file"; then
            # Update first empty occurrence (handles spaces around =)
            sed -i -E "0,/${empty_regex}/s/${empty_regex}/${varname}=${new_value}/" "$file"
            echo "Updated empty ${varname} with new value" >&2
        else
            echo "Preserving existing non-empty value for ${varname}" >&2
            return 0
        fi
    else
        # Add new entry (with newline if file doesn't end with one)
        [ -s "$file" ] && [ -z "$(tail -c 1 "$file")" ] || echo >> "$file"
        echo "${varname}=${new_value}" >> "$file"
        echo "Added new ${varname} entry" >&2
    fi
}

_apt-get-install () {
    DPKG=`dpkg -l`
    packages=("$@")
    for file in "${packages[@]}"; do
        if ! echo "$DPKG" | grep -qF "$file"; then
            DEBIAN_FRONTEND=noninteractive apt-get install -y $@
            break
        fi
    done
}

_apt-get-update() {
    # Usage: apt_update_if_needed [max_age_hours] (default: 24)
    local max_age_hours=${1:-24}
    local last_update
    local current_time
    local time_diff

    # Get last update time (in seconds since epoch)
    last_update=$(stat -c %Y /var/lib/apt/periodic/update-success-stamp 2>/dev/null || \
                  stat -c %Y /var/lib/apt/lists/ 2>/dev/null || \
                  echo 0)

    current_time=$(date +%s)
    time_diff=$(( (current_time - last_update) / 3600 ))  # Convert to hours

    if [ "$time_diff" -ge "$max_age_hours" ]; then
        echo "APT last updated ${time_diff} hours ago. Running apt-get update..."
        apt-get update -qq
        touch /var/lib/apt/periodic/update-success-stamp
        echo "APT package lists updated"
    else
        echo "APT updated recently (${time_diff} hours ago). Skipping."
    fi
}

_replace_or_add_line() {
    # Usage: _replace_or_add_line "file" "pattern" "new_line"
    local file="$1"
    local pattern="$2"
    local new_line="$3"
    local temp_file
    
    # Create temp file in the same directory as original
    temp_dir="$(dirname "$file")"
    temp_file="$(mktemp -p "$temp_dir")" || return 1
    
    # Process the file
    if grep -q "$pattern" "$file"; then
        # Special handling for ^ start anchor
        if [[ "$pattern" == ^* ]]; then
            # Remove ^ for the replacement pattern
            local sed_pattern="${pattern#^}"
            sed -i -E "0,/^${sed_pattern}/s|^${sed_pattern}.*|$new_line|" "$file"
        else
            # Normal replacement
            sed -i -E "s|${pattern}.*|$new_line|" "$file"
        fi
    else
        # Append new line
        cp "$file" "$temp_file"
        echo "$new_line" >> "$file"
    fi
    
}

gen_keys() {

    [ "$(id -u)" -eq 0 ] || { echo "This script must be run as root" >&2; exit 1; }

    cd ${BASEDIR}

    [ -f .env ] || cp env.example .env

    _apt-get-update
    _apt-get-install pwgen

    local bootpass=$(grep -E '^[a-zA-Z]{4,8}$' /usr/share/dict/words | shuf -n4 | tr '\n' ' ' | sed 's/ $//' && echo)
    _add_if_missing_or_empty ".env" "PG_PASS" `pwgen -s 32`
    _add_if_missing_or_empty ".env" "AUTHENTIK_SECRET_KEY" `pwgen -s 32`
    _add_if_missing_or_empty ".env" "AUTHENTIK_BOOTSTRAP_PASSWORD" "\"$bootpass\""

}

push() {
    # Usage: push hostname

    cd ${BASEDIR}

    local dest="$1:/opt/authentik/"

    echo Copying local files to $dest
    rsync -avz --progress \
        --exclude='.env/' \
        --exclude='.git/' \
        --exclude='.gitignore' \
        --exclude='.gitmodules' \
        --exclude='.gitattributes' \
        --exclude='*.swp' \
        --exclude='.DS_Store' \
        ./ "root@$dest"
}

install() {

    [ "$(id -u)" -eq 0 ] || { echo "This script must be run as root" >&2; exit 1; }

    cd ${BASEDIR}

    _apt-get-install docker.io docker-compose

    # make our data dirs
    mkdir -p data
    cd data
    mkdir -p certs media postgres redis templates
    cd ..

    gen_keys

    # wire it up to systemd
    ln -sf ${BASEDIR}/authentik.service /etc/systemd/system/authentik.service
    systemctl daemon-reload
    systemctl enable authentik
}

"$@" # <- execute the task
[ "$#" -gt 0 ] || printf "Usage:\n\t./${SCRIPTNAME} %s\n" "($(compgen -A function | grep '^[^_]' | paste -sd '|' -))"

